"""
Модуль single_instance.py


Назначение
---------
Обеспечение единственности экземпляра приложения на основе Qt.
Использует механизм `QSharedMemory` для проверки и блокировки повторного запуска.


Состав
------
- Класс `SingleInstance`, который работает с разделяемой памятью:
* `already_running()` — проверяет, запущен ли другой экземпляр.
* `claim_ownership()` — создаёт сегмент памяти и тем самым закрепляет за собой «право владения».


Примечания
---------
- Для идентификации используется строковый ключ (по умолчанию "__hotkey_singleton__").
- Реализация кроссплатформенная, так как основана на Qt.
"""

from PyQt6 import QtCore


class SingleInstance:
    """Класс для ограничения приложения одним экземпляром.


    Аргументы конструктора
    ----------------------
    key : str
    Уникальный строковый ключ для идентификации сегмента памяти.


    Методы
    ------
    already_running() -> bool
    Возвращает True, если сегмент памяти с ключом уже существует,
    то есть запущен другой экземпляр приложения
    claim_ownership() -> bool
    Пытается создать сегмент памяти (размером 1 байт).
    Возвращает True, если удалось создать сегмент и данный процесс стал владельцем.
    """

    def __init__(self, key="b3763eeb-ec63-4245-a014-5fd2b240e294"):
        # key - сгенерированный UUID

        self.mem = QtCore.QSharedMemory(key)

    def already_running(self) -> bool:
        """
        True, если сегмент памяти с ключом уже существует (другой процесс запущен).
        Подключается к сегменту только для проверки и сразу отцепляется.
        """
        if self.mem.attach():  # сегмент есть → кто-то уже создал
            self.mem.detach()  # мы не пользуемся им — просто проверяли
            return True
        return False

    def request_ownership(self) -> bool:
        """
        Пытается создать сегмент (размер 1 байт). Возвращает True,
        если создание удалось и теперь этот процесс — «владелец» ключа.
        Если другая программа, в конкурентом режиме, захватила память, то "тапки её"
        """
        return self.mem.create(1)
